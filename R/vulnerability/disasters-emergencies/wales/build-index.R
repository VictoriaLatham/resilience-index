# Load libraries and functions
library(tidyverse)
library(psych)
library(recipes)
library(corrr)
library(ggplot2)
library(tidytext)
library(GGally)
source("R/utils.R")

# 1. Load indicators
wales_vulnerability_indicators <-
  load_indicators(
    path = "data/vulnerability/disasters-emergencies/wales",
    key = "lad_code"
  )

# 2. Scale indicator, High value = high vulnerability
# !!!skewness still exits, 0.78
wales_vulnerability_scaled <-
  wales_vulnerability_indicators %>%
  mutate(
    access_to_service = log(access_to_service * -1), # avoid skewness and scale indicator
    access_to_internet = log(access_to_internet * -1),
    disability = log(disability), # avoid skewness
    elderly_population = sqrt(elderly_population), # avoid skewness
    housing = (housing * -1)**(1 / 3), # avoid skewness, use cube root
    living_alone = log(living_alone) # avoid skewness, !!!skewness still exits, 0.78
  )

print("skewness before:")
describe(wales_vulnerability_indicators)
print("skewness after:")
describe(wales_vulnerability_scaled)

# 3. Normalise indicator
wales_vulnerability_normlised <-
  wales_vulnerability_scaled %>%
  normalise_indicators()

print("After normalised:")
describe(wales_vulnerability_normlised)

# 4. Correlation check
## Sadly, no strong correlation :(
wales_vulnerability_normlised %>%
  select(where(is.numeric)) %>%
  correlate() %>%
  rearrange()

## Correlation plot
ggpairs(select(wales_vulnerability_normlised, where(is.numeric))) + theme_bw()

# 5. PCA
wales_recipe <-
  recipe(~., data = wales_vulnerability_normlised) %>%
  update_role(lad_code, new_role = "id") %>%
  step_pca(all_predictors(), id = "pca") %>%
  prep()

# 6. indentify the number of latent facors
# Criteria1: explanation of variance percentage greater than 10%
# Criteria2: cumulative explanation of variance percentage greater than 60%
# here we choose 2 components
pca_variation_stat <-
  wales_recipe %>%
  tidy(id = "pca", type = "variance") %>%
  filter(
    terms == "cumulative percent variance" |
      terms == "percent variance" |
      terms == "variance"
  ) %>%
  pivot_wider(names_from = terms, values_from = value) %>%
  select(-id) %>%
  rename(
    percent_variance = `percent variance`,
    cumulative_percent_variance = `cumulative percent variance`
  )

# 7. rotation of factos
pca_rotation <-
  wales_recipe %>%
  tidy(id = "pca") %>%
  pivot_wider(names_from = terms, values_from = value) %>%
  select(-id)

# 8. Squared factor loading (scaled to unity sum)
squared_factor_loading <-
  pca_rotation %>%
  select(-component) %>%
  mutate_all(function(x) (x**2) / sum(x**2))

# Concat all pca statistical infomation together
pca_stat <-
  bind_cols(
    squared_factor_loading, pca_variation_stat
  )

# 9. calculate the weight of each variable
pca_weight <-
  pca_stat %>%
  slice_head(n = 2) %>% # only keep 2 components
  mutate(
    percent_variance = percent_variance / 100, # convert to decimal
    access_to_service = access_to_service * percent_variance,
    access_to_internet = access_to_internet * percent_variance,
    disability = disability * percent_variance,
    elderly_population = elderly_population * percent_variance,
    housing = housing * percent_variance,
    living_alone = living_alone * percent_variance
  ) %>%
  select(access_to_internet, access_to_service, disability, elderly_population, housing, living_alone) %>%
  summarise(across(where(is.numeric), ~ sum(.x, na.rm = TRUE)))

# Extract weights
weights <-
  pca_weight |>
  pivot_longer(cols = everything()) |>
  rename(weight = value) |>
  pull(weight)

# Multiply model weights by respective column to get weighted indicators
weighted_indicators <-
  wales_vulnerability_normlised %>%
  select(-lad_code) %>%
  map2_dfc(weights, `*`) %>%
  select_all(list(~ str_c(., "_weighted"))) |>
  add_column(
    lad_code = wales_vulnerability_normlised$lad_code,
    .before = "access_to_internet_weighted"
  )

# Sum
vulnerability <-
  weighted_indicators |>
  calculate_domain_scores(domain_name = "vulnerability")

write_csv(
  vulnerability,
  "data/vulnerability/disasters-emergencies/wales/index-weighted.csv"
)

# ---- Exploratory code ----
# library(sf)
# library(geographr)
# library(viridis)
# # vulnerability visualization
# shp <-
#   boundaries_lad %>%
#   filter(str_detect(lad_code, "^W"))

# wales_vul_shp <-
#   shp %>%
#   left_join(output, by = "lad_code")

# wales_vul_shp %>%
#   select(deciles, geometry) %>%
#   ggplot() +
#   geom_sf(
#     mapping = aes(fill = deciles),
#     size = 0.1
#   ) +
#   scale_fill_viridis(
#     option = "magma",
#     alpha = 0.8,
#     begin = 0.1,
#     end = 0.9,
#     discrete = F,
#     direction = -1,
#     guide = guide_legend(
#       title = "",
#       label = TRUE,
#       keyheight = unit(8, units = "mm"),
#       reverse = T
#     )
#   ) +
#   labs(title = "Vulnerability deciles in Wales") +
#   theme(plot.margin = unit(c(0.5, 1.5, 0.5, 1.5), "cm"))

# # Some PCA plots
# # 1.Examine how much variance each component accounts for
# wales_recipe %>%
#   tidy(id = "pca", type = "variance") %>%
#   filter(terms == "percent variance") %>%
#   ggplot(aes(x = component, y = value)) +
#   geom_col(fill = "#b6dfe2") +
#   xlim(c(0, 5)) +
#   ylab("% of total variance")

# # Examine how much cumulative variance each component accounts for
# wales_recipe %>%
#   tidy(id = "pca", type = "variance") %>%
#   filter(terms == "cumulative percent variance") %>%
#   ggplot(aes(x = component, y = value)) +
#   geom_col(fill = "#b6dfe2") +
#   xlim(c(0, 5)) +
#   ylab("cumulative percent variance")

# # plot loadings by principal component
# wales_recipe %>%
#   tidy(id = "pca") %>%
#   mutate(terms = reorder_within(terms, abs(value), component)) %>%
#   ggplot(aes(abs(value), terms, fill = value > 0)) +
#   geom_col() +
#   facet_wrap(~component, scales = "free_y") +
#   scale_y_reordered() +
#   scale_fill_manual(values = c("#b6dfe2", "#0A537D")) +
#   labs(
#     x = "Absolute value of contribution",
#     y = NULL, fill = "Positive?"
#   )

# plot_histogram(wales_vulnerability_normlised)